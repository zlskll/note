# 比特第一次测评：

<img src="D:%5CTypora%5C%E5%9B%BE%E7%89%87%5Cimage-20221130202740247.png" alt="image-20221130202740247" style="zoom:50%;" />

什么是tmd顶级边路啊！

麻蛋，直接数，

![image-20221130204935618](D:%5CTypora%5C%E5%9B%BE%E7%89%87%5Cimage-20221130204935618.png)

语法规定的是语言规则，关键字，操作符这些，标准库函数的实现由编译器提供，所以C语言本身没有输入输出函数，库函数这些，库函数都是由编译器提供的，实现方法不一样，但最终实现的结果是一样的。

# 求最小公倍数：

<img src="D:%5CTypora%5C%E5%9B%BE%E7%89%87%5Cimage-20221130211101355.png" alt="image-20221130211101355" style="zoom:67%;" />

效率较低↑

效率较高↓

<img src="D:%5CTypora%5C%E5%9B%BE%E7%89%87%5Cimage-20221130211413624.png" alt="image-20221130211413624" style="zoom:50%;" />

只需找五次，往常3-15要12次，3和5尚且如此

所以效率较高的→<img src="D:%5CTypora%5C%E5%9B%BE%E7%89%87%5Cimage-20221130211549784.png" alt="image-20221130211549784" style="zoom:67%;" />

在此基础上可以求最大公约数，因为  最小公倍数 * 最大公约数=a *b；

# 逆序单词串：

![image-20221130212330370](D:%5CTypora%5C%E5%9B%BE%E7%89%87%5Cimage-20221130212330370.png)

scanf("% [ ^ \n ]",arr) ;是除了读到换行，都不停止

逆序整个字符串简单，但是逆序每个单词就要注意了

<img src="D:%5CTypora%5C%E5%9B%BE%E7%89%87%5Cimage-20221130213803722.png" alt="image-20221130213803722" style="zoom:67%;" />

while等待法必须会，可以先想一个单词怎么逆序，然后循环起来

注意最后一个单词的特殊性，因为最后一个单词的末尾不是空格，而是斜杠0



法二：写两个函数，一个是逆序整个，一个是逆序单词，同样是注意最后一个单词的斜杠0特殊性

法三：就利用\0的特殊性，我把它变得不特殊不就行了，直接把所有空格变成\0，然后用%s打印，完美