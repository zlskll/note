## char->%u和%d整形提升

<img src="D:\Typora\图片\image-20221006171957471.png" alt="image-20221006171957471" style="zoom: 50%;" />

unsigned 整形提升的时候会直接往前加0，跟对待正数一样

int是signed Int

short是signed short

但是char不一定是signed  char，这得看编译器。

<img src="D:\Typora\图片\image-20221006172117486.png" alt="image-20221006172117486" style="zoom:50%;" />

结果是4294967168。

a(char)是10000000，打印的是%u，不管是u还是d都是整形，就要先进行整形提升得到补码，然后再看是%u，原反补相同，于是就是11111111111111111111111110000000,计算器一算就是上面那个得数。

如果是%d,就是先根据补码写出原码，然后再读出来对应的十进制数字。

所以%u %d的区别是对于整形提升后的补码是不是有符号的，无符号原反补相同，有符号原反补不同。

## 谈一下char的存储范围

char是1个字节8个bit位，2^8个数字，-128~127

正数(原反补相同) 00000000(0) ——01111111(127)

负数(原反补不同，下面均为补码)

11111111(10000001= -1)——10000000(11111111= -128)

<img src="D:\Typora\图片\image-20221006172218766.png" alt="image-20221006172218766" style="zoom:50%;" />



> ​                     （如果一直是char类型的）

```c
int main(){
    int i=-20;
    unsigned int j=10;
    printf("%d\n",i+j);//结果是-10
    return 0;
}
```

首先写出i=-20的二进制序列（是原码），然后转化为补码，再写出j=10的原码(=补码)，都是整形，就不会发生整形提升了，补码相加，得到一串补码，最后是%d，内存就认为那串补码是有符号的，又因为最高位是1，所以需要原反补转换得到原码,10000000000000000000000000001010，读出来就是-10.