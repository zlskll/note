# 字符串常量在内存中的存储

![image-20221008193317479](D:\Typora\图片\image-20221008193317479.png)



结果应该是not same / same。

![image-20221008194049093](D:\Typora\图片\image-20221008194049093.png)

str1[]和str2[]都是数组，是局部变量，在栈区，会将处于静态存储区的字符串常量拷贝到自己的内存空间(在栈区)内，由于str1和str2是两个名字不同的数组，所以空间位置不同，str1(str1[]的首元素的地址)当然 !=str2(str2[]的首元素的地址)了，所以此时有了hellobit的两个拷贝，一个存在静态存储区，一个存在栈区(数组，局部变量)。

而str3和str4是指针，存储了字符串hellobit的首元素h的地址，而这个地址是在字符串常量所在地 静态存储区的，只是把静态存储区的那个拷贝的首元素的地址存到了栈区的指针里，所以你现在*ps='w';想改字符串常量的值，绝对不行，因为字符串常量是在静态存储区，不允许再更改。因为只有一份拷贝，所以str3和str4指向的都是同一个hellobit的h，地址是一样的，所以str3==str4就理所应当了。

# 指针数组

存放指针(指针也是地址)的数组就是指针数组。

<img src="D:\Typora\图片\image-20221008212102861.png" alt="image-20221008212102861" style="zoom:67%;" />

<img src="D:\Typora\图片\image-20221008212727472.png" alt="image-20221008212727472" style="zoom: 67%;" />

这样的写法语法上是没错的，但是没有应用场景，就是说没什么用，但是可以放进去，所以更加深了指针就是地址的理解，int* p=&a;p是专门开辟出来的、用于存放指针的一个变量，所以叫指针变量，而不是说p是个指针，指针明明是地址怎么能和变量空间混为一谈。而解引用符号*就相当于根据p存放的那个地址，找到地址指向的位置，这个位置可以是常量`(字符串常量可以吧)`，也可以是变量`(a可以吧)`，看你存什么。因此，不加 *是地址，加了 *就是地址指向的东西。

一个数组的数组名就是首元素的地址，是个指针，这个指针指向栈区`（局部变量）（一般数组都是局部变量，如果你硬放到全局那当我没说`）的一块连续的内存空间，就是当初定义数组时申请的空间，本质上还是变量，只是几个变量空间凑一块了。

p++的意思其实就是p存放的指针(地址)++，使用的是变量里面的内容，就像i++一样，只是i的值++了而已，别想太多。

<img src="D:\Typora\图片\image-20221008214617744.png" alt="image-20221008214617744" style="zoom:67%;" />

<img src="D:\Typora\图片\image-20221008214647638.png" alt="image-20221008214647638" style="zoom:67%;" />

跟二维数组神似，但也不完全是，只能算是模拟吧，因为二维数组是连续存放的，而int*虽然是连续的，但int *指向的数组位置不一定挨着的，所以这跟二维数组还是不太一样的。

<img src="D:\Typora\图片\image-20221008215806893.png" alt="image-20221008215806893" style="zoom:67%;" />

浮点型数据存进去，整形数据读取打印的错误打开方式：

![image-20221008221011550](D:\Typora\图片\image-20221008221011550.png)

正确打开方式：

<img src="D:\Typora\图片\image-20221008220911208.png" alt="image-20221008220911208" style="zoom: 80%;" />

不能是浮点型存进去，浮点型拿出来变成(-1)^S *M * 2^E的形式，又以整形方式打印，编译器转不过来，就报错了。

只能是以浮点型存进去，浮点型拿出来然后强制类型传化成int形式的，再打印。

# 数组指针

它是一种指向数组本身的指针。

<img src="D:\Typora\图片\image-20221008222541905.png" alt="image-20221008222541905" style="zoom:80%;" />

为什么不是int *parr=&arr：

​           这样会报错的，因为&arr是取了整个数组的地址，整个数组可不是int * 啊，存放到了int *里不就类型不匹配了吗？所以不行

为什么不是int *parr[10]=&arr：

​            这样会混淆的，因为这样的形式其实是指针数组，由于[]的优先级比*高，所以parr优先和[ ]结合，一和[ ]结合就坏事了，直接变成parr[10]这个存放指针的数组，然后这个数组加个 *表示parr[10]的每个元素是int *类型，数组指针直接误变指针数组。(我tm直呼好家伙)



```c
double* d[5];//d[5]是一个存放指针的大小为5的的指针数组
double*(*pd)[5]=&d;//(* xx)是告诉编译器：pd是个指针这件事已经定死了，[ ]必须是5，因为存的是整个数组，那个数组就那么大，写多了就浪费了，况且，写多的部分编译器不知道怎么补，毕竟以前指针指向的都是一个变量空间，根本没这种情况(说白了就是情况少见标准懒得规定了呗)
//double*还是double是看存的数组里面的元素的类型,这里是个普通的指针有点不同的，因为数组的类型和数组元素的类型肯定还是不同的，要不然下边怎么解释！(冒汗)
```

![image-20221008224047370](D:\Typora\图片\image-20221008224047370.png)

地址值一样，只能说明指向的初始地方一样，但意义是不一样的，即类型不一样，有两个理由：

第一个理由是类型不一样，就比如  ![image-20221008224235053](D:\Typora\图片\image-20221008224235053.png) 

值一样，能说明这俩一样吗？当然不能，因为类型不同，各自的用法是不一样的，如果是arr的话(数组首元素的地址)，应该用int* p=arr；因为存的是一个变量；如果是&arr(整个数组)，就应该用上面的方法了，完全不同啊对不对。

第二个理由是，指针+1表示一步跳过多远，而这个步长是由指针类型决定的，如果指针类型是字符型，就跳过1个字节，是整形就跳过4个字节，因此如果是数组型，就跳过一个数组大小那么远，因此类型不一样，意义是完全不一样的。 

## 数组名的两个例外

一般情况下数组名就是数组首元素的地址，除了以下两个例外：

1.sizeof(数组名)，计算的是整个数组的大小，单位是字节

2.&数组名，这里的数组名表示整个数组整体，取出的是整个数组的地址。(数组的地址和数组首元素的地址的区别就好比武中教学楼的地址和那个教学楼101房间的地址)。(大师，我悟了！)

存档，[105. 指针进阶_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1cq4y1U7sg?p=108&spm_id_from=pageDriver&vd_source=c98fed8fc1104fd30934a3e22864c4a0)

27：00

