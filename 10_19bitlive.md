![image-20221019192336208](D:%5CTypora%5C%E5%9B%BE%E7%89%87%5Cimage-20221019192336208.png)

# 计算机的各种数据存储器：

寄存器：byte字节（访问速度最快）（造价最高）（空间最小）

高速缓存：M兆

内存：8G/16G

硬盘：512G

网盘：2T（最慢）（造价最低）

早期内存和CPU速度相配，随着技术发展，CPU处理速度越来越快，但存储发展的速度跟不上，速度差的越来越多，于是出现了高速缓存和寄存器，CPU从访问速度最快的寄存器中取数据，内存中的数据源源不断的通过高速缓存传到寄存器，这样速度就跟上了。

# static：

## static：

修饰局部变量：

局部变量本身是没有外部链接属性的，出作用域

修饰全局变量：

全局变量在整个工程的，在A文件中定义的变量，在B文件中可以【链接】(extern)使用，本身具有外部链接属性，但是static修饰会把外部链接属性变成内部链接属性，于是全局变量的作用域变小了，无法链接到别的文件，限制了它的作用域(把它的作用域变小了)

修饰函数：

函数没有生命周期这一概念，因为它没有在内存中存储，只是段代码，只有能不能调用的问题，不调用啥事没有，一旦调用会触发函数栈帧申请变量（？？？csdn了解一下+笔记本）

一个函数本身是具有外部链接属性的，可以通过extern 声明到其他文件里用，但是static修饰它以后，它就被“隔离”了，只能在文件内部使用，其他文件不能使用。（和全局变量非常类似）

# define定义的符号、宏：

## 定义符号：

​     是全局的，但不是全局变量，因为他就是个符号。

## 定义宏：

#define MAX( x , y )   (x > y ? x : y)

​            宏名   宏参数   （宏体）

宏会被它的宏体替换。

和函数很相似，但也有不同，宏没有返回类型，因为是直接替换。

 一般宏处理的不是什么复杂的东西，函数是处理复杂的东西。

# 指针：

讨论指针，首先要理解内存。

程序运行的时候都会载入内存，程序中如果需要进行数据存储，也会申请内存空间。

为了有效的使用内存空间，内存会划分成一个个小的内存单元，（实践中一个内存单元是一个字节）同时会给这些一个个的内存单元编号，这就是内存单元的地址，C语言中地址就叫作指针。

那内存单元的地址是怎么产生的呢？

以32位机器为例，它有32根地址线，地址线如果通电，电信号会转成数字信号1或0，所以就有了32位全0到32位全1的二进制序列（2^32个），就可以作为2的32次方个地址，就可以管理2的32次方个内存单元，也就是2的32次方个内存空间（也就是接近43个亿个字节），也就是4个GB的空间，64位机器就是1600万个T了，很大，不会出现访问不够的情况。

写程序分配内存的时候，是操作系统帮助我们弄的，具体操作还是由操作系统决定的，因此同一段代码，不同执行的时候，分配的地址不一定一样。

十六进制中，四位二进制位对应一位十六进制。

%p专门用来打印地址。打印一个4字节整形的时候，打印的是第一个字节的地址。（可以测试一下）

0开头的是八进制的数，0x开头的是十六进制的。

下面进入正题——指针。

<img src="D:%5CTypora%5C%E5%9B%BE%E7%89%87%5Cimage-20221019211304972.png" alt="image-20221019211304972" style="zoom: 67%;" />



![image-20221019211352109](D:%5CTypora%5C%E5%9B%BE%E7%89%87%5Cimage-20221019211352109.png)

把地址放到指针变量里面，目的是能够通过指针变量找到指向的能够变量，而 * 解引用操作 - 作用就是通过pa中的地址找到a，*pa <=> a

![image-20221019211633228](D:%5CTypora%5C%E5%9B%BE%E7%89%87%5Cimage-20221019211633228.png)



typedef是对类型重定义，也可以对指针类型重定义。

